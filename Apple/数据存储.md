# 数据存储


<!-- create time: 2014-10-12 18:49:10  -->

转自传智PPT

    每个iOS应用都有自己的应用沙盒(应用沙盒就是文件系统目录)，与其他文件系统隔离。
    应用必须待在自己的沙盒里，其他应用不能访问该沙盒
    
    目录结构
    --Documents //保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。
                //例如，游戏应用可将游戏存档保存在该目录
    --Library
        --Caches //保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。
                 //一般存储体积大、不需要备份的非重要数据

        --Preferences //保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中
                      //查找应用的设置信息。iTunes同步设备时会备份该目录
    --tmp  //保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。
           //应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录

常用的几种存储方式

0. [应用沙盒目录的常见获取方式](#anchor0)
1. [XML属性列表（plist）归档](#anchor1)
2. [Preference(偏好设置)](#anchor2)
3. [NSKeyedArchiver归档(NSCoding)](#anchor3)
4. [SQLite3](#anchor4)
5. [Core Data](#anchor5)




***

<h3 id="anchor0">应用沙盒目录的常见获取方式 </h3>

1. 沙盒根目录：`NSString *home = NSHomeDirectory();` ->程序根目录
 
2. Documents文件夹目录： 
 * 利用沙盒根目录拼接”Documents”字符串(不推荐) 
   1. ` NSString *home = NSHomeDirectory(); `   
   2. `NSString *documents = [home stringByAppendingPathComponent:@"Documents"];`   
 * 利用NSSearchPathForDirectoriesInDomains函数 
   1. `NSArray *array =  NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, NO);`   
      * NSUserDomainMask 代表从用户文件夹下找
      * YES 代表展开路径中的波浪字符“~”      
   2. `NSString *documents = [array objectAtIndex:0];` //在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素 
   
     
3. tmp文件夹获取:`NSString *tmp = NSTemporaryDirectory();`


4. Library/Caches获取 
   1. 利用沙盒根目录拼接”Library/Caches”字符串（不推荐）
   2. 利用NSSearchPorDirectoriesInDomains函数
      * `NSArray *array =  NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSCachesDirectory, NO);`
      * `NSString *documents = [array objectAtIndex:0];`


5. Library/Preference：通过NSUserDefaults类存取该目录下的设置信息 

<h3 id="anchor1">XML属性列表（plist）归档 </h3>

    属性列表是一种XML格式的文件，拓展名为plist
如果对象是`NSString、NSDictionary、NSArray、NSData、NSNumber`等类型，就可以使用`writeToFile:atomically:`方法直接将对象写到属性列表文件中

objective-c:

    -->写入
    // 将数据封装成字典
    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    [dict setObject:@"母鸡" forKey:@"name"];
    [dict setObject:@"15013141314" forKey:@"phone"];
    [dict setObject:@"27" forKey:@"age"];
    // 将字典持久化到Documents/stu.plist文件中
    [dict writeToFile:path atomically:YES];
    -->读取
    // 读取Documents/stu.plist的内容，实例化NSDictionary
    NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];




<h3 id="anchor2">Preference(偏好设置) </h3>

    保存用户名、密码、字体大小等设置，iOS提供了一套标准的解决方案来为应用加入偏好设置功能
    每个应用都有个NSUserDefaults实例，通过它来存取偏好设置
 
 objective-c:
     
    -->写入
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    [defaults setObject:@"itcast" forKey:@"username"];
    [defaults setFloat:18.0f forKey:@"text_size"];
    [defaults setBool:YES forKey:@"auto_login"];
    -->读取
    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
    NSString *username = [defaults stringForKey:@"username"];
    float textSize = [defaults floatForKey:@"text_size"];
    BOOL autoLogin = [defaults boolForKey:@"auto_login"];
    
    [defaults synchornize];
    
    注意：UserDefaults设置数据时，不是立即写入，
    而是根据时间戳定时地把缓存中的数据写入本地磁盘。
    所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。
    出现以上问题，可以通过调用synchornize方法强制写入
    

<h3 id="anchor3">NSKeyedArchiver归档(NSCoding) </h3>

    如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver进行归档和恢复
    不是所有的对象都可以直接用这种方法进行归档，只有遵守了NSCoding协议的对象才可以


* 遵守NSCoding协议的2个方法:
    1. `encodeWithCoder:`每次归档对象时，都会调用这个方法。一般在这个方法里面指定如何归档对象中的每个实例变量，可以使用encodeObject:forKey:方法归档实例变量
    2. `initWithCoder:`每次从文件中恢复(解码)对象时，都会调用这个方法。一般在这个方法里面指定如何解码文件中的数据为对象的实例变量，可以使用decodeObject:forKey方法解码实例变量

* 归档(编码)

   objvetive-c:
   
       Person *person = [[[Person alloc] init] autorelease];
       person.name = @"Zhu";
       person.age = 23;
       person.height = 1.83f;
       [NSKeyedArchiver archiveRootObject:person toFile:path];
* 恢复(解码)

    objvetive-c:

        Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:path];

* 注意
    1. 归档／恢复 NSArray对象
        objvetive-c:
            
            -->归档
            NSArray *array = [NSArray arrayWithObjects: @"a", @"b",nil];
            [NSKeyedArchiver archiveRootObject:array toFile:path];

            -->读取
            NSArray *array = [NSKeyedUnarchiver unarchiveObjectWithFile:path];
    2. 归档对象时注意 
    
        1. 如果父类也遵守了NSCoding协议，请注意：应该在encodeWithCoder:方法中加上一句
        
            [super encodeWithCode:encode];确保继承的实例变量也能被编码，即也能被归档
            
        2. 应该在initWithCoder:方法中加上一句self = [super initWithCoder:decoder];

            确保继承的实例变量也能被解码，即也能被恢复
           
<h3 id="anchor4">SQLite3 </h3>




<h3 id="anchor5">Core Data </h3>
